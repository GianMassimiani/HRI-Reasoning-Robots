<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Shared Modules &mdash; LTLMoP v0.6 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '#',
        VERSION:     '0.6',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LTLMoP v0.6 documentation" href="index.html" />
    <link rel="next" title="Handlers" href="handlers.html" />
    <link rel="prev" title="Applications" href="applications.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="handlers.html" title="Handlers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="applications.html" title="Applications"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">LTLMoP v0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-createJTLVinput">
<h1>Shared Modules<a class="headerlink" href="#module-createJTLVinput" title="Permalink to this headline">¶</a></h1>
<div class="section" id="project-py-abstraction-layer-for-project-files">
<h2>project.py - Abstraction layer for project files<a class="headerlink" href="#project-py-abstraction-layer-for-project-files" title="Permalink to this headline">¶</a></h2>
<p>This module exposes an object that allows for simplified loading of the
various files included in a single project.</p>
<dl class="class">
<dt id="project.Project">
<em class="property">class </em><tt class="descclassname">project.</tt><tt class="descname">Project</tt><a class="headerlink" href="#project.Project" title="Permalink to this definition">¶</a></dt>
<dd><p>A project object.</p>
<dl class="method">
<dt id="project.Project.determineEnabledPropositions">
<tt class="descname">determineEnabledPropositions</tt><big>(</big><big>)</big><a class="headerlink" href="#project.Project.determineEnabledPropositions" title="Permalink to this definition">¶</a></dt>
<dd>Populate <tt class="docutils literal"><span class="pre">all_sensors</span></tt>, <tt class="docutils literal"><span class="pre">initial_sensors</span></tt>, and <tt class="docutils literal"><span class="pre">all_actuators</span></tt> lists based on
configuration information.</dd></dl>

<dl class="method">
<dt id="project.Project.getBackgroundImagePath">
<tt class="descname">getBackgroundImagePath</tt><big>(</big><big>)</big><a class="headerlink" href="#project.Project.getBackgroundImagePath" title="Permalink to this definition">¶</a></dt>
<dd>Returns the path of the background image with regions drawn on top, created by RegionEditor</dd></dl>

<dl class="method">
<dt id="project.Project.getCoordMaps">
<tt class="descname">getCoordMaps</tt><big>(</big><em>exp_cfg_data</em><big>)</big><a class="headerlink" href="#project.Project.getCoordMaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns forward (map-&gt;lab) and reverse (lab-&gt;map) coordinate mapping functions, in that order</p>
<p>We are currently assuming the transformation is only linear, not affine (TODO).</p>
</dd></dl>

<dl class="method">
<dt id="project.Project.getExperimentConfig">
<tt class="descname">getExperimentConfig</tt><big>(</big><em>exp_cfg_name</em><big>)</big><a class="headerlink" href="#project.Project.getExperimentConfig" title="Permalink to this definition">¶</a></dt>
<dd>Returns a dictionary corresponding to the specified experiment config</dd></dl>

<dl class="method">
<dt id="project.Project.getFilenamePrefix">
<tt class="descname">getFilenamePrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#project.Project.getFilenamePrefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full path of most project files, minus the extension.</p>
<p>For example, if the spec file of this project is <tt class="docutils literal"><span class="pre">/home/ltlmop/examples/test/test.spec</span></tt>
then this function will return <tt class="docutils literal"><span class="pre">/home/ltlmop/examples/test/test</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="project.Project.importHandlers">
<tt class="descname">importHandlers</tt><big>(</big><em>list=None</em><big>)</big><a class="headerlink" href="#project.Project.importHandlers" title="Permalink to this definition">¶</a></dt>
<dd><p>Load in specified handlers.  If no list is given, <em>all</em> handlers will be loaded.</p>
<p>Note that the order of loading is important, due to inter-handler dependencies.</p>
</dd></dl>

<dl class="method">
<dt id="project.Project.loadLabData">
<tt class="descname">loadLabData</tt><big>(</big><em>exp_cfg_data</em><big>)</big><a class="headerlink" href="#project.Project.loadLabData" title="Permalink to this definition">¶</a></dt>
<dd>Takes an experiment config dictionary and returns a lab config dictionary.</dd></dl>

<dl class="method">
<dt id="project.Project.loadProject">
<tt class="descname">loadProject</tt><big>(</big><em>spec_file</em>, <em>exp_cfg_name=None</em><big>)</big><a class="headerlink" href="#project.Project.loadProject" title="Permalink to this definition">¶</a></dt>
<dd>Because the spec_file contains references to all other project files, this is all we
need to know in order to load everything in.</dd></dl>

<dl class="method">
<dt id="project.Project.loadRegionFile">
<tt class="descname">loadRegionFile</tt><big>(</big><big>)</big><a class="headerlink" href="#project.Project.loadRegionFile" title="Permalink to this definition">¶</a></dt>
<dd>Returns a Region File Interface object corresponding to the regions file referenced in the spec file</dd></dl>

<dl class="method">
<dt id="project.Project.loadRobotFile">
<tt class="descname">loadRobotFile</tt><big>(</big><em>exp_cfg_data</em><big>)</big><a class="headerlink" href="#project.Project.loadRobotFile" title="Permalink to this definition">¶</a></dt>
<dd>Takes an experiment config dictionary and returns a robot description dictionary.</dd></dl>

<dl class="method">
<dt id="project.Project.loadSpecFile">
<tt class="descname">loadSpecFile</tt><big>(</big><em>spec_file</em><big>)</big><a class="headerlink" href="#project.Project.loadSpecFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="project.Project.lookupHandlers">
<tt class="descname">lookupHandlers</tt><big>(</big><big>)</big><a class="headerlink" href="#project.Project.lookupHandlers" title="Permalink to this definition">¶</a></dt>
<dd>Figure out which handlers we are going to use, based on the different configurations file settings</dd></dl>

<dl class="method">
<dt id="project.Project.runInitialization">
<tt class="descname">runInitialization</tt><big>(</big><em>calib=False</em><big>)</big><a class="headerlink" href="#project.Project.runInitialization" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the necessary initialization handlers.</p>
<p>We treat initialization handlers separately, because there may be more than one.
NOTE: These will be loaded in the same order as they are listed in the lab config file.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="regions-py-regions-module">
<h2>regions.py - Regions Module<a class="headerlink" href="#regions-py-regions-module" title="Permalink to this headline">¶</a></h2>
<p>A simple module that defines a class for describing and manipulating
rectangular and polygonal regions.</p>
<p>This is completely free software; please feel free to adapt or use this in
any way you like.</p>
<p>Some parts extracted from pySketch by Erik Westra (<a class="reference external" href="mailto:ewestra&#37;&#52;&#48;wave&#46;co&#46;nz">ewestra<span>&#64;</span>wave<span>&#46;</span>co<span>&#46;</span>nz</a>)</p>
<dl class="class">
<dt id="regions.Region">
<em class="property">class </em><tt class="descclassname">regions.</tt><tt class="descname">Region</tt><big>(</big><em>type=1</em>, <em>position=wx.Point(0</em>, <em>0)</em>, <em>size=wx.Size(0</em>, <em>0)</em>, <em>color=None</em>, <em>points=</em><span class="optional">[</span><span class="optional">]</span>, <em>name=''</em><big>)</big><a class="headerlink" href="#regions.Region" title="Permalink to this definition">¶</a></dt>
<dd><p>A rectangular or polygonal region, defined by the following properties:</p>
<blockquote>
<ul>
<li><p class="first">&#8216;name&#8217;          Region name</p>
</li>
<li><p class="first">&#8216;type&#8217;          What type of region this is (rect or poly)</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;position&#8217;      The position of the object within the document </dt>
<dd><p class="first last">(i.e., the top-left corner of the region&#8217;s bounding-box)</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;size&#8217;          The size of the object&#8217;s bounding box</p>
</li>
<li><p class="first">&#8216;color&#8217;         Color to use for drawing the region</p>
</li>
<li><p class="first">&#8216;pointArray&#8217;    Polygon points, relative to region position (stored in CW order)</p>
</li>
<li><p class="first">&#8216;alignmentPoints&#8217;  True/False array indicating for each vertex whether or not to use it as an alignment point</p>
</li>
</ul>
</blockquote>
<dl class="docutils">
<dt>NOTE: All coordinates are stored internally with (0,0) at the top left.</dt>
<dd>X increases to right, and Y increases downwards.</dd>
</dl>
<dl class="method">
<dt id="regions.Region.addPoint">
<tt class="descname">addPoint</tt><big>(</big><em>point</em>, <em>index</em><big>)</big><a class="headerlink" href="#regions.Region.addPoint" title="Permalink to this definition">¶</a></dt>
<dd>Insert a new point at a given index, converting object type if necessary</dd></dl>

<dl class="method">
<dt id="regions.Region.getCenter">
<tt class="descname">getCenter</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.Region.getCenter" title="Permalink to this definition">¶</a></dt>
<dd>Find the &#8216;center&#8217; of a region</dd></dl>

<dl class="method">
<dt id="regions.Region.getData">
<tt class="descname">getData</tt><big>(</big><em>withAlignment=True</em><big>)</big><a class="headerlink" href="#regions.Region.getData" title="Permalink to this definition">¶</a></dt>
<dd>Return a copy of the object&#8217;s internal data.
This is used for undo and to save this region to disk.</dd></dl>

<dl class="method">
<dt id="regions.Region.getDirection">
<tt class="descname">getDirection</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.Region.getDirection" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine convexity/concavity and the order of the points stored in the pointArray.
For details on the algorithm, please refer to:</p>
<blockquote>
<a class="reference external" href="http://local.wasp.uwa.edu.au/~pbourke/geometry/clockwise/index.html">http://local.wasp.uwa.edu.au/~pbourke/geometry/clockwise/index.html</a></blockquote>
</dd></dl>

<dl class="method">
<dt id="regions.Region.getFaces">
<tt class="descname">getFaces</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.Region.getFaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper function to allow for iteration over faces of regions.
A face is a tuple of the two points (in absolute coordinates) that make up the face,
sorted so that a given face is defined uniquely.</p>
<p>FIXME: Make sure we take advantage of this uniqueness elsewhere; I think we check
too many conditions sometimes</p>
</dd></dl>

<dl class="method">
<dt id="regions.Region.getPoints">
<tt class="descname">getPoints</tt><big>(</big><em>relative=False</em><big>)</big><a class="headerlink" href="#regions.Region.getPoints" title="Permalink to this definition">¶</a></dt>
<dd>Wrapper function to allow for iteration over the points of a region without
worrying about whether it&#8217;s a RECT or POLY.</dd></dl>

<dl class="method">
<dt id="regions.Region.getSelectionHandleContainingPoint">
<tt class="descname">getSelectionHandleContainingPoint</tt><big>(</big><em>x</em>, <em>y</em>, <em>boundFunc=None</em><big>)</big><a class="headerlink" href="#regions.Region.getSelectionHandleContainingPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the selection handle containing the given point, if any.</p>
<p>We return one of the predefined selection handle ID codes (defined at top).</p>
</dd></dl>

<dl class="method">
<dt id="regions.Region.objectContainsPoint">
<tt class="descname">objectContainsPoint</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#regions.Region.objectContainsPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True iff this object contains the given point.</p>
<p>This is used to determine if the user clicked on the object.</p>
</dd></dl>

<dl class="method">
<dt id="regions.Region.objectWithinRect">
<tt class="descname">objectWithinRect</tt><big>(</big><em>x</em>, <em>y</em>, <em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#regions.Region.objectWithinRect" title="Permalink to this definition">¶</a></dt>
<dd>Return True iff this object falls completely within the given rect.</dd></dl>

<dl class="method">
<dt id="regions.Region.recalcBoundingBox">
<tt class="descname">recalcBoundingBox</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.Region.recalcBoundingBox" title="Permalink to this definition">¶</a></dt>
<dd>Recalculate the bounding box for our object</dd></dl>

<dl class="method">
<dt id="regions.Region.removePoint">
<tt class="descname">removePoint</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#regions.Region.removePoint" title="Permalink to this definition">¶</a></dt>
<dd>Remove the point at the given index, converting object type if necessary</dd></dl>

<dl class="method">
<dt id="regions.Region.setData">
<tt class="descname">setData</tt><big>(</big><em>data</em>, <em>withAlignment=True</em><big>)</big><a class="headerlink" href="#regions.Region.setData" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the object&#8217;s internal data.</p>
<p>&#8216;data&#8217; is a copy of the object&#8217;s saved data, as returned by
getData() above.  This is used for undo and to restore a 
previously saved region.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="regions.RegionFileInterface">
<em class="property">class </em><tt class="descclassname">regions.</tt><tt class="descname">RegionFileInterface</tt><big>(</big><em>background='None'</em>, <em>regions=</em><span class="optional">[</span><span class="optional">]</span>, <em>transitions=None</em>, <em>thumb=None</em><big>)</big><a class="headerlink" href="#regions.RegionFileInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper class for handling collections of regions and associated metadata.</p>
<p>Overview of exposed data structures:</p>
<blockquote>
<ul>
<li><p class="first">background (string): relative path of background image file</p>
</li>
<li><p class="first">regions (list): list of Region objects, with properties defined below</p>
</li>
<li><dl class="first docutils">
<dt>transitions (list of lists):</dt>
<dd><ul class="first last simple">
<li>key1 = Region object index</li>
<li>key2 = Region object index</li>
<li>values = Lists of faces connecting the two regions</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>thumb (string): relative path of an image file that shows the regions overlayed </dt>
<dd><p class="first last">on the background image, made by taking a screenshot</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<dl class="method">
<dt id="regions.RegionFileInterface.getCalibrationPoints">
<tt class="descname">getCalibrationPoints</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.getCalibrationPoints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regions.RegionFileInterface.getNextAvailableRegionNumber">
<tt class="descname">getNextAvailableRegionNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.getNextAvailableRegionNumber" title="Permalink to this definition">¶</a></dt>
<dd>Look for the smallest region name of form r1, r2, ... available.</dd></dl>

<dl class="method">
<dt id="regions.RegionFileInterface.indexOfRegionWithName">
<tt class="descname">indexOfRegionWithName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.indexOfRegionWithName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regions.RegionFileInterface.readFile">
<tt class="descname">readFile</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.readFile" title="Permalink to this definition">¶</a></dt>
<dd>For file format information, refer to writeFile() above.</dd></dl>

<dl class="method">
<dt id="regions.RegionFileInterface.setToDefaultName">
<tt class="descname">setToDefaultName</tt><big>(</big><em>region</em><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.setToDefaultName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="regions.RegionFileInterface.writeFile">
<tt class="descname">writeFile</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#regions.RegionFileInterface.writeFile" title="Permalink to this definition">¶</a></dt>
<dd>File format is described inside the comments variable.</dd></dl>

</dd></dl>

<dl class="function">
<dt id="regions.pointLineIntersection">
<tt class="descclassname">regions.</tt><tt class="descname">pointLineIntersection</tt><big>(</big><em>pt1</em>, <em>pt2</em>, <em>test_pt</em><big>)</big><a class="headerlink" href="#regions.pointLineIntersection" title="Permalink to this definition">¶</a></dt>
<dd>Given two points (pt1, pt2), find the point on the line formed by those points that is nearest
to test_pt and give the distance.</dd></dl>

</div>
<div class="section" id="fsa-py-finite-state-automaton-module">
<h2>fsa.py - Finite-State Automaton module<a class="headerlink" href="#fsa-py-finite-state-automaton-module" title="Permalink to this headline">¶</a></h2>
<p>Defines a specific model for finite state automata, including a method to read in files
produced by JTLV and a method to execute the automaton.</p>
<dl class="class">
<dt id="fsa.Automaton">
<em class="property">class </em><tt class="descclassname">fsa.</tt><tt class="descname">Automaton</tt><big>(</big><em>regions</em>, <em>sensor_handler</em>, <em>actuator_handler</em>, <em>motion_handler</em><big>)</big><a class="headerlink" href="#fsa.Automaton" title="Permalink to this definition">¶</a></dt>
<dd><p>An automaton object is a collection of state objects along with information about the
current state of the automaton when being executed.</p>
<dl class="method">
<dt id="fsa.Automaton.chooseInitialState">
<tt class="descname">chooseInitialState</tt><big>(</big><em>init_region</em>, <em>init_outputs</em><big>)</big><a class="headerlink" href="#fsa.Automaton.chooseInitialState" title="Permalink to this definition">¶</a></dt>
<dd><p>Search through all our states to find one that satisfies our current system and environment states,
so that we may begin our execution from there.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">init_region</span></tt> is the number of our starting region</li>
<li><tt class="docutils literal"><span class="pre">init_outputs</span></tt> is a list of output proposition names that are TRUE initially.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.dumpStates">
<tt class="descname">dumpStates</tt><big>(</big><big>)</big><a class="headerlink" href="#fsa.Automaton.dumpStates" title="Permalink to this definition">¶</a></dt>
<dd>Print out the contents of the automaton in a human-readable format</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.findTransitionableStates">
<tt class="descname">findTransitionableStates</tt><big>(</big><em>initial=False</em><big>)</big><a class="headerlink" href="#fsa.Automaton.findTransitionableStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of states that we could conceivably transition to, given
the environment state (determined by querying the sensor handler)</p>
<p>If <tt class="docutils literal"><span class="pre">initial</span></tt> is true, the current region and output propositions will constrain
state selection as well.</p>
</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.loadFile">
<tt class="descname">loadFile</tt><big>(</big><em>filename</em>, <em>sensors</em>, <em>actuators</em>, <em>custom_props</em><big>)</big><a class="headerlink" href="#fsa.Automaton.loadFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an automaton by reading in a file produced by TLV.</p>
<p>In addition to a filename, you also need to provide a list of sensor names (so that we can tell the difference between system and environment propositions when reading the file), and a list of actuator names (so we can distinguish internal state propositions from outputs).</p>
<p>Basically just a lot of regexes.</p>
</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.regionFromState">
<tt class="descname">regionFromState</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#fsa.Automaton.regionFromState" title="Permalink to this definition">¶</a></dt>
<dd>Given a state object, look at its &#8216;bitX&#8217; outputs to determine the region encoded,
and return the NUMBER of this region.</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.runIteration">
<tt class="descname">runIteration</tt><big>(</big><big>)</big><a class="headerlink" href="#fsa.Automaton.runIteration" title="Permalink to this definition">¶</a></dt>
<dd>Run, run, run the automaton!  (For one evaluation step)</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.stateWithName">
<tt class="descname">stateWithName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#fsa.Automaton.stateWithName" title="Permalink to this definition">¶</a></dt>
<dd>Find the state with the given name</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.updateOutputs">
<tt class="descname">updateOutputs</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#fsa.Automaton.updateOutputs" title="Permalink to this definition">¶</a></dt>
<dd>Update the values of current outputs in our execution environment to reflect the output
proposition values associated with the given state</dd></dl>

<dl class="method">
<dt id="fsa.Automaton.writeDot">
<tt class="descname">writeDot</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#fsa.Automaton.writeDot" title="Permalink to this definition">¶</a></dt>
<dd>Write a dot file so we can look at the automaton visually.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="fsa.FSA_State">
<em class="property">class </em><tt class="descclassname">fsa.</tt><tt class="descname">FSA_State</tt><big>(</big><em>name</em>, <em>inputs</em>, <em>outputs</em>, <em>transitions</em><big>)</big><a class="headerlink" href="#fsa.FSA_State" title="Permalink to this definition">¶</a></dt>
<dd><p>Each state in the automaton is an object.</p>
<p>WARNING/FIXME: Since all states belong to a list within the Automaton object, the states may
also be referred to just by their index within that list.  This can get confusing sometimes.</p>
</dd></dl>

</div>
<div class="section" id="filemethods-py-file-access-methods">
<h2>fileMethods.py - File Access Methods<a class="headerlink" href="#filemethods-py-file-access-methods" title="Permalink to this headline">¶</a></h2>
<p>Some routines for reading and writing plaintext config/data files, shared throughout the toolkit.</p>
<dl class="function">
<dt id="fileMethods.properCase">
<tt class="descclassname">fileMethods.</tt><tt class="descname">properCase</tt><big>(</big><em>str</em><big>)</big><a class="headerlink" href="#fileMethods.properCase" title="Permalink to this definition">¶</a></dt>
<dd>Returns a copy of a string, with the first letter capitalized and all others lower-case
(<em>CURRENTLY DOES NOTHING</em>, and I&#8217;m not sure why that change was made)</dd></dl>

<dl class="function">
<dt id="fileMethods.readFromFile">
<tt class="descclassname">fileMethods.</tt><tt class="descname">readFromFile</tt><big>(</big><em>fileName</em><big>)</big><a class="headerlink" href="#fileMethods.readFromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple method for reading in data from text files of the following format:</p>
<div class="highlight-python"><pre>========= SECTION1 ==========

# COMMENT

HEADER1: # COMMENT
DATA1
DATA2

HEADER2: # COMMENT
DATA3

========= SECTION2 ===========

HEADER1:
DATA1</pre>
</div>
<p>Given a file with the above contents, the function will return the following dictionary of dictionaries:</p>
<div class="highlight-python"><pre>{ 'SECTION1' : { 'HEADER1': ['DATA1', 'DATA2'],
                 'HEADER2': ['DATA3'] },
{ 'SECTION2' : { 'HEADER1': ['DATA1'] } }</pre>
</div>
<dl class="docutils">
<dt>NOTE:</dt>
<dd><ul class="first last simple">
<li>Headers <em>must</em> be followed by a colon</li>
<li>Section names must have at least one equals sign on both sides</li>
<li>Dictionary keys will always be normalized so that only the first letter is capitalized (<em>CURRENTLY DISABLED</em>)</li>
<li>All items are returned as strings and should be cast to the appropriate type before
use, if appropriate</li>
<li>Lines beginning with <tt class="docutils literal"><span class="pre">#</span></tt> are treated as comments</li>
<li>Blank lines at the end of sections are ignored</li>
<li>Any data without a section title will be returned under the empty string key: <tt class="docutils literal"><span class="pre">''</span></tt></li>
<li>If no section titles are present, the outer dictionary will be ommitted</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="fileMethods.writeToFile">
<tt class="descclassname">fileMethods.</tt><tt class="descname">writeToFile</tt><big>(</big><em>fileName</em>, <em>data</em>, <em>comments={}</em><big>)</big><a class="headerlink" href="#fileMethods.writeToFile" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple method for writing data to text files of the format described in the <a title="fileMethods.readFromFile" class="reference internal" href="#fileMethods.readFromFile"><tt class="xref docutils literal"><span class="pre">readFromFile()</span></tt></a>
function above.</p>
<p>All data will be output in key-sorted order for the sake of consistency.</p>
<p>Any items in the comments hash whose keys match those of the data hash will be included
as comments in the appropriate section of the file.</p>
<p>If it exists, the comment keyed as <tt class="docutils literal"><span class="pre">&quot;FILE_HEADER&quot;</span></tt> will be added to the top of the output file.</p>
</dd></dl>

</div>
<div class="section" id="parseenglishtoltl-py-structured-english-to-ltl-translator">
<h2>parseEnglishToLTL.py - Structured English to LTL Translator<a class="headerlink" href="#parseenglishtoltl-py-structured-english-to-ltl-translator" title="Permalink to this headline">¶</a></h2>
<p>Module that parses a set of structured English sentences into the
corresponding LTL subformulas.</p>
<dl class="function">
<dt id="parseEnglishToLTL.bitEncoding">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">bitEncoding</tt><big>(</big><em>numRegions</em>, <em>numBits</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.bitEncoding" title="Permalink to this definition">¶</a></dt>
<dd>This function creates a dictionary that contains the bit encoding for the current
and next region. Takes number of regions and returns a dictionary with &#8216;current&#8217;         and &#8216;next&#8217; as keys, each containing a list of the respective encodings.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.createStayFormula">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">createStayFormula</tt><big>(</big><em>numBits</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.createStayFormula" title="Permalink to this definition">¶</a></dt>
<dd>This function replaces the region names with the appropriate bit encoding.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseCond">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseCond</tt><big>(</big><em>condition</em>, <em>sensorList</em>, <em>allRobotProp</em>, <em>ReqType</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseCond" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formula representing the condition part of a conditional.
It takes the condition and PropList - a list of propositions (to check that only &#8216;legal&#8217;
propositions are used)and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns the LTL formula as a string.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseConditional">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseConditional</tt><big>(</big><em>Condition</em>, <em>ReqFormulaInfo</em>, <em>CondType</em>, <em>sensorList</em>, <em>allRobotProp</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseConditional" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formula representing a conditional.
It takes the condition, the requirement formula (that was already parsed),
the condition type, and the list of all propositions (to check that only &#8216;legal&#8217;
propositions are used) and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns a dictionary with 2 keys: &#8216;formula&#8217; containing the LTL formula as a string and &#8216;type&#8217; containing
the type of the requirement.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseEvent">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseEvent</tt><big>(</big><em>EventProp</em>, <em>SetEvent</em>, <em>ResetEvent</em>, <em>sensorProp</em>, <em>RobotProp</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseEvent" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formulas encoding when a proposition should be true and when false.
This is used as a macro to define &#8216;memory&#8217; propositions.
It takes the proposition, the boolean formulas defining the set and reset events, the propositions
(to check that only &#8216;legal&#8217; propositions are used) and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns the LTL formula as a string.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseInit">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseInit</tt><big>(</big><em>sentence</em>, <em>PropList</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseInit" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formula representing the initial conditions.
It takes the sentence and PropList - a list of propositions (to check that only &#8216;legal&#8217;
propositions are used) and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns the LTL formula as a string.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseLiveness">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseLiveness</tt><big>(</big><em>sentence</em>, <em>sensorList</em>, <em>allRobotProp</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseLiveness" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formula representing a basic liveness requirement.
It takes the sentence, the sensor list and the list of all robot propositions (to check that only &#8216;legal&#8217;
propositions are used and to determine whether it is an environment safety or a robot one)
and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns a dictionary with 2 keys: &#8216;formula&#8217; containing the LTL formula as a string and &#8216;type&#8217; containing
either &#8216;EnvGoals&#8217; or &#8216;SysGoals&#8217;.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.parseSafety">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">parseSafety</tt><big>(</big><em>sentence</em>, <em>sensorList</em>, <em>allRobotProp</em>, <em>lineInd</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.parseSafety" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the LTL formula representing a basic safety requirement.
It takes the sentence, the sensor list and the list of all robot propositions (to check that only &#8216;legal&#8217;
propositions are used and to determine whether it is an environment safety or a robot one)
and &#8216;lineInd&#8217; that indicates which line is being processed.
Returns a dictionary with 2 keys: &#8216;formula&#8217; containing the LTL formula as a string and &#8216;type&#8217; containing
either &#8216;EnvTrans&#8217; or &#8216;SysTrans&#8217;.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.replaceLogicOp">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">replaceLogicOp</tt><big>(</big><em>formula</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.replaceLogicOp" title="Permalink to this definition">¶</a></dt>
<dd>This function replaces the logic operators with TLV convention.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.replaceRegionName">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">replaceRegionName</tt><big>(</big><em>formula</em>, <em>bitEncode</em>, <em>regionList</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.replaceRegionName" title="Permalink to this definition">¶</a></dt>
<dd>This function replaces the region names with the appropriate bit encoding.</dd></dl>

<dl class="function">
<dt id="parseEnglishToLTL.writeSpec">
<tt class="descclassname">parseEnglishToLTL.</tt><tt class="descname">writeSpec</tt><big>(</big><em>text</em>, <em>sensorList</em>, <em>regionList</em>, <em>robotPropList</em><big>)</big><a class="headerlink" href="#parseEnglishToLTL.writeSpec" title="Permalink to this definition">¶</a></dt>
<dd>This function creates the Spec dictionary that contains the parsed LTL
subformulas. It takes the text that contains the structured English,
the list of sensor propositions, the list containing
the region names and the list of robot propositions (other than regions).</dd></dl>

</div>
<div class="section" id="createjtlvinput-py-ltl-pre-processor-routines">
<h2>createJTLVinput.py - LTL Pre-Processor Routines<a class="headerlink" href="#createjtlvinput-py-ltl-pre-processor-routines" title="Permalink to this headline">¶</a></h2>
<p>Module that creates the input files for the JTLV based synthesis algorithm.
Its functions create the skeleton .smv file and the .ltl file which
includes the topological relations and the given spec.</p>
<dl class="function">
<dt id="createJTLVinput.createLTLfile">
<tt class="descclassname">createJTLVinput.</tt><tt class="descname">createLTLfile</tt><big>(</big><em>fileName</em>, <em>sensorList</em>, <em>robotPropList</em>, <em>adjData</em>, <em>spec</em><big>)</big><a class="headerlink" href="#createJTLVinput.createLTLfile" title="Permalink to this definition">¶</a></dt>
<dd>This function writes the LTL file. It encodes the specification and 
topological relation. 
It takes as input a filename, the list of the
sensor propositions, the list of robot propositions (without the regions),
the adjacency data (transition data structure) and
a dictionary containing the specification strings.</dd></dl>

<dl class="function">
<dt id="createJTLVinput.createSMVfile">
<tt class="descclassname">createJTLVinput.</tt><tt class="descname">createSMVfile</tt><big>(</big><em>fileName</em>, <em>numRegions</em>, <em>sensorList</em>, <em>robotPropList</em><big>)</big><a class="headerlink" href="#createJTLVinput.createSMVfile" title="Permalink to this definition">¶</a></dt>
<dd>This function writes the skeleton SMV file.
It takes as input a filename, the number of regions, the list of the
sensor propositions and the list of robot propositions (without the regions).</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Shared Modules</a><ul>
<li><a class="reference external" href="#project-py-abstraction-layer-for-project-files">project.py - Abstraction layer for project files</a></li>
<li><a class="reference external" href="#regions-py-regions-module">regions.py - Regions Module</a></li>
<li><a class="reference external" href="#fsa-py-finite-state-automaton-module">fsa.py - Finite-State Automaton module</a></li>
<li><a class="reference external" href="#filemethods-py-file-access-methods">fileMethods.py - File Access Methods</a></li>
<li><a class="reference external" href="#parseenglishtoltl-py-structured-english-to-ltl-translator">parseEnglishToLTL.py - Structured English to LTL Translator</a></li>
<li><a class="reference external" href="#createjtlvinput-py-ltl-pre-processor-routines">createJTLVinput.py - LTL Pre-Processor Routines</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="applications.html"
                                  title="previous chapter">Applications</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="handlers.html"
                                  title="next chapter">Handlers</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/modules.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="handlers.html" title="Handlers"
             >next</a> |</li>
        <li class="right" >
          <a href="applications.html" title="Applications"
             >previous</a> |</li>
        <li><a href="index.html">LTLMoP v0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Cameron Finucane, Gangyuan (Jim) Jing, Hadas Kress-Gazit.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.4.
    </div>
  </body>
</html>